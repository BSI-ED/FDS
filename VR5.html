<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fresque Chronologique VR - Quest 2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #000; font-family: Arial, sans-serif; overflow: hidden; color: white; }
        #info { position: absolute; top: 10px; left: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; max-width: 300px; }
        #enterVR { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; background: linear-gradient(145deg, #ff6b35, #f7931e); color: white; border: none; padding: 15px 30px; border-radius: 25px; font-size: 18px; font-weight: bold; cursor: pointer; box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4); transition: all 0.3s ease; }
        #enterVR:hover { transform: translateX(-50%) scale(1.05); box-shadow: 0 8px 25px rgba(255, 107, 53, 0.6); }
        #enterVR:disabled { background: #666; cursor: not-allowed; box-shadow: none; }
        #controls { position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; }
        .control-btn { background: #333; color: white; border: none; padding: 8px 12px; margin: 2px; border-radius: 5px; cursor: pointer; }
        .control-btn:hover { background: #555; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 999; text-align: center; font-size: 18px; }
        .progress-bar { width: 200px; height: 4px; background: #333; border-radius: 2px; margin: 10px auto; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #ff6b35, #f7931e); width: 0%; transition: width 0.3s; }
        #vrStatus { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(0,0,0,0.9); padding: 10px 20px; border-radius: 10px; color: #ffd700; display: none; }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Chargement VR...</h2>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <p id="loadingText">Initialisation...</p>
    </div>
    <div id="vrStatus"><p id="statusText"></p></div>
    <div id="info">
        <h3>Fresque Chronologique VR</h3>
        <p><strong>Quest 2:</strong> Gachette pour sélectionner</p>
        <p><strong>VR:</strong> Joystick pour téléportation</p>
        <p><strong>Navigation:</strong> Grip alternatif</p>
        <p><small>Symbole Venus (♀) = Femme scientifique</small></p>
    </div>
    <div id="controls">
        <button class="control-btn" onclick="resetView()">Reset</button>
        <button class="control-btn" onclick="toggleAutoRotate()">Auto</button>
        <button class="control-btn" onclick="randomSelection()">Random</button>
    </div>
    <button id="enterVR">Entrer en VR</button>

    <script>
        const items = [
            {id:1, cat:'Ingénieur', name:'Leonardo de Vinci', years:'1452-1519', year:1500, gender:'M',
             img:'proto/leonardo.jpg',
             short:'Polymathe de la Renaissance : peintre, ingénieur, inventeur.',
             bio:'Ses carnets mêlent études d\'anatomie, d\'ingénierie, d\'hydraulique et d\'optique.'},
            {id:2, cat:'Ingénieur', name:'Sébastien Le Prestre de Vauban', years:'1633-1707', year:1670, gender:'M',
             img:'proto/Vauban.jpg',
             short:'Maréchal et maître des fortifications sous Louis XIV.',
             bio:'Refonda l\'art du siège et des forteresses en Europe.'},
            {id:3, cat:'Ingénieur', name:'Joseph et Étienne Montgolfier', years:'1740-1810', year:1783, gender:'M',
             img:'proto/montgolfier.jpg',
             short:'Cofondateurs de l\'aérostation à air chaud.',
             bio:'En 1783, lancement des premiers ballons à air chaud habités.'},
            {id:4, cat:'Ingénieur', name:'Claude Chappe', years:'1763-1805', year:1794, gender:'M',
             img:'proto/chappe.jpg',
             short:'Inventeur du télégraphe optique (sémaphore).',
             bio:'Un réseau de tours sémaphores transmit rapidement des dépêches d\'État avant l\'ère électrique.'},
            {id:5, cat:'Ingénieur', name:'Charles Babbage', years:'1792-1871', year:1837, gender:'M',
             img:'proto/Babbage.jpg',
             short:'Concepteur de la machine analytique (proto-ordinateur).',
             bio:'Imagina une machine programmable à cartes, avec mémoire et unité de calcul, préfigurant l\'ordinateur.'},
            {id:6, cat:'Ingénieur', name:'Gustave Eiffel', years:'1832-1923', year:1889, gender:'M',
             img:'proto/Eiffel.jpg',
             short:'Ingénieur des structures métalliques, à l\'origine de la tour Eiffel.',
             bio:'La Tour Eiffel et le viaduc de Garabit ; travaux en aérodynamique et résistance des matériaux.'},
            {id:7, cat:'Ingénieur', name:'Clément Ader', years:'1841-1925', year:1890, gender:'M',
             img:'proto/Ader.jpg',
             short:'Pionnier français de l\'aviation (Éole).',
             bio:'Appareils expérimentaux et travaux d\'aérodynamique avant les vols contrôlés.'},
            {id:8, cat:'Ingénieur', name:'Thomas Edison', years:'1847-1931', year:1880, gender:'M',
             img:'proto/Edison.jpg',
             short:'Inventeur prolifique (lampe, phonographe, cinéma).',
             bio:'Menlo Park : R&D industrielle, plus d\'un millier de brevets.'},
            {id:9, cat:'Ingénieur', name:'George Eastman', years:'1854-1932', year:1900, gender:'M',
             img:'proto/Eastman.jpg',
             short:'Fondateur de Kodak ; popularise la photographie.',
             bio:'Films souples et appareils abordables ; démocratisation de la photo.'},
            {id:10, cat:'Ingénieur', name:'Henry Ford', years:'1863-1947', year:1913, gender:'M',
             img:'proto/ford.jpg',
             short:'Production de masse automobile.',
             bio:'Chaîne de montage, Ford T ; transformation industrielle et sociale.'},
            {id:20, cat:'Savant', name:'Galileo Galilei', years:'1564-1642', year:1610, gender:'M',
             img:'proto/galilee.jpg',
             short:'Fondateur de la physique moderne et de l\'astronomie expérimentale.',
             bio:'Observations télescopiques (lunes de Jupiter), méthode expérimentale, défense de l\'héliocentrisme.'},
            {id:21, cat:'Savant', name:'Isaac Newton', years:'1642-1727', year:1687, gender:'M',
             img:'proto/newton.jpg',
             short:'Lois du mouvement et de la gravitation universelle.',
             bio:'Principia Mathematica ; optique et calcul infinitésimal.'},
            {id:22, cat:'Savant', name:'William Herschel', years:'1738-1822', year:1781, gender:'M',
             img:'proto/william-herschel.jpg',
             short:'Découvreur d\'Uranus ; pionnier de l\'astronomie infrarouge.',
             bio:'Cartographie de la Voie lactée ; découverte du rayonnement infrarouge.'},
            {id:23, cat:'Savant', name:'Blaise Pascal', years:'1623-1662', year:1654, gender:'M',
             img:'proto/pascal.jpg',
             short:'Mathématicien, physicien et philosophe.',
             bio:'Presse hydraulique, machine à calculer (Pascaline), probabilités.'},
            {id:24, cat:'Savant', name:'Georg Simon Ohm', years:'1789-1854', year:1827, gender:'M',
             img:'proto/ohm.jpg',
             short:'Physicien, il formule la loi d\'Ohm sur la résistance électrique',
             bio:'Relation U=RI, fondement de l\'électrocinétique.'},
            {id:25, cat:'Savant', name:'Sadi Carnot', years:'1796-1832', year:1824, gender:'M',
             img:'proto/carnot.jpg',
             short:'Fondateur de la thermodynamique.',
             bio:'Cycle de Carnot ; rendements des machines thermiques.'},
            {id:26, cat:'Savant', name:'Charles Darwin', years:'1809-1882', year:1859, gender:'M',
             img:'proto/darwin.jpg',
             short:'Théorie de l\'évolution par sélection naturelle.',
             bio:'« L\'Origine des espèces » ; observations au cours du Beagle.'},
            {id:27, cat:'Savant', name:'Marie Curie', years:'1867-1934', year:1903, gender:'F',
             img:'proto/marie-curie.jpg',
             short:'Radioactivité ; deux prix Nobel.',
             bio:'Découverte du polonium et du radium ; physique et chimie de la radioactivité.'},
            {id:28, cat:'Savant', name:'Albert Einstein', years:'1879-1955', year:1915, gender:'M',
             img:'proto/einstein.jpg',
             short:'Relativité restreinte et générale.',
             bio:'Effet photoélectrique (Nobel), équivalence masse-énergie, espace-temps courbe.'},
            {id:29, cat:'Savant', name:'Max Planck', years:'1858-1947', year:1900, gender:'M',
             img:'proto/planck.jpg',
             short:'Fondateur de la mécanique quantique.',
             bio:'Hypothèse de quantification de l\'énergie ; constante de Planck.'},
            {id:30, cat:'Savant', name:'Hypathie d\'Alexandrie', years:'355-415', year:400, gender:'F',
             img:'proto/hypatia.jpg',
             short:'Mathématicienne, astronome et philosophe grecque.',
             bio:'Enseigna les mathématiques et l\'astronomie à Alexandrie. Commentaires sur Diophante et Apollonius.'},
            {id:31, cat:'Savant', name:'Émilie du Châtelet', years:'1706-1749', year:1740, gender:'F',
             img:'proto/emilie-du-chatelet.jpg',
             short:'Mathématicienne et physicienne, traductrice de Newton.',
             bio:'Sa traduction commentée des Principia diffusa la physique newtonienne en France ; travaux sur l\'énergie et la chaleur.'}
        ];

        items.sort((a,b) => a.year - b.year);

        let scene, camera, renderer, characters = [], raycaster, mouse, clock, isVRActive = false, autoRotate = false;
        let xrSession = null, xrReferenceSpace = null, gl = null, infoPanel = null, selectedCharacter = null;
        let controllers = [], controllerGrips = [], teleportMarker = null, currentTeleportPosition = null;
        let dolly = null;

        async function init() {
            try {
                updateLoadingProgress(10, "Configuration...");
                clock = new THREE.Clock();
                
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0b0c10);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 1.6, 5);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.xr.enabled = true;
                gl = renderer.getContext();
                document.body.appendChild(renderer.domElement);
                
                updateLoadingProgress(30, "Setup VR...");
                await setupVR();
                
                updateLoadingProgress(40, "Sol...");
                createFloor();
                
                updateLoadingProgress(50, "Lumières...");
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                scene.add(directionalLight);
                
                const spotLight1 = new THREE.SpotLight(0xff6b35, 0.5, 50, Math.PI/4);
                spotLight1.position.set(-15, 8, 0);
                spotLight1.target.position.set(0, 0, 0);
                scene.add(spotLight1);
                scene.add(spotLight1.target);
                
                const spotLight2 = new THREE.SpotLight(0x3b82f6, 0.5, 50, Math.PI/4);
                spotLight2.position.set(15, 8, 0);
                spotLight2.target.position.set(0, 0, 0);
                scene.add(spotLight2);
                scene.add(spotLight2.target);
                
                updateLoadingProgress(70, "Personnages...");
                createCharacters();
                
                updateLoadingProgress(80, "Téléportation...");
                createTeleportMarker();
                
                updateLoadingProgress(90, "Interactions...");
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                window.addEventListener('resize', onWindowResize);
                
                createInfoPanel();
                updateLoadingProgress(100, "Prêt!");
                animate();
                
                setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 1000);
            } catch (error) {
                console.error('Erreur init:', error);
                document.getElementById('loadingText').textContent = 'Erreur: ' + error.message;
            }
        }

        function updateLoadingProgress(progress, text) {
            const progressFill = document.getElementById('progressFill');
            const loadingText = document.getElementById('loadingText');
            if (progressFill) progressFill.style.width = progress + '%';
            if (loadingText) loadingText.textContent = text;
        }

        function setupVR() {
            const vrButton = document.getElementById('enterVR');
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        vrButton.style.display = 'block';
                        vrButton.onclick = toggleVR;
                    } else {
                        vrButton.textContent = 'VR non supportée';
                        vrButton.disabled = true;
                    }
                }).catch(() => {
                    vrButton.textContent = 'Mode Émulateur VR';
                    vrButton.onclick = simulateVR;
                });
            } else {
                vrButton.textContent = 'Mode Émulateur VR';
                vrButton.onclick = simulateVR;
            }
        }

        async function toggleVR() {
            if (!isVRActive) {
                try {
                    const session = await navigator.xr.requestSession('immersive-vr');
                    renderer.xr.setSession(session);
                    xrSession = session;
                    isVRActive = true;
                    document.getElementById('enterVR').textContent = 'Quitter VR';
                    showVRStatus('VR active!', 'success');
                    
                    try {
                        xrReferenceSpace = await session.requestReferenceSpace('local-floor');
                    } catch (e) {
                        try {
                            xrReferenceSpace = await session.requestReferenceSpace('bounded-floor');
                        } catch (e2) {
                            xrReferenceSpace = await session.requestReferenceSpace('local');
                        }
                    }
                    
                    const controller1 = renderer.xr.getController(0);
                    const controller2 = renderer.xr.getController(1);
                    
                    controller1.addEventListener('selectstart', onSelectStart);
                    controller2.addEventListener('selectstart', onSelectStart);
                    controller1.addEventListener('selectend', onSelectEnd);
                    controller2.addEventListener('selectend', onSelectEnd);
                    controller1.addEventListener('squeezestart', onSqueezeStart);
                    controller2.addEventListener('squeezestart', onSqueezeStart);
                    
                    scene.add(controller1);
                    scene.add(controller2);
                    controllers = [controller1, controller2];
                    
                    const rayGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, -5)
                    ]);
                    const ray1 = new THREE.Line(rayGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                    const ray2 = new THREE.Line(rayGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
                    controller1.add(ray1);
                    controller2.add(ray2);
                    
                    const grip1 = renderer.xr.getControllerGrip(0);
                    const grip2 = renderer.xr.getControllerGrip(1);
                    scene.add(grip1);
                    scene.add(grip2);
                    controllerGrips = [grip1, grip2];
                    
                    dolly = new THREE.Group();
                    dolly.position.set(0, 0, 0);
                    dolly.add(camera);
                    scene.add(dolly);
                    
                    session.addEventListener('end', onVRSessionEnd);
                } catch (error) {
                    console.error('Erreur VR:', error);
                    showVRStatus('Erreur VR: ' + error.message, 'error');
                }
            } else {
                if (xrSession) xrSession.end();
            }
        }

        function onVRSessionEnd() {
            xrSession = null;
            xrReferenceSpace = null;
            isVRActive = false;
            document.getElementById('enterVR').textContent = 'Entrer en VR';
            showVRStatus('VR terminée', 'info');
        }

        function simulateVR() {
            isVRActive = !isVRActive;
            document.getElementById('enterVR').textContent = isVRActive ? 'Quitter Émulateur' : 'Mode Émulateur VR';
            showVRStatus(isVRActive ? 'Émulation active' : 'Émulation désactivée', 'info');
        }

        function showVRStatus(message, type = 'info') {
            const statusDiv = document.getElementById('vrStatus');
            const statusText = document.getElementById('statusText');
            if (statusText) statusText.textContent = message;
            if (statusDiv) {
                statusDiv.style.display = 'block';
                statusDiv.style.color = type === 'success' ? '#4ade80' : type === 'error' ? '#f87171' : '#ffd700';
                setTimeout(() => { statusDiv.style.display = 'none'; }, 5000);
            }
        }

        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.userData.isFloor = true;
            scene.add(floor);
            
            const gridHelper = new THREE.GridHelper(100, 100, 0x666666, 0x333333);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }

        function createCharacters() {
            const radius = 15;
            for (let i = 0; i < items.length; i++) {
                const char = items[i];
                const angle = (i / items.length) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                createCharacterModel(char, x, 0, z, i);
            }
        }

        async function loadCharacterImage(character) {
            return new Promise((resolve) => {
                if (character.img && character.img.startsWith('data:image')) {
                    const loader = new THREE.TextureLoader();
                    loader.load(character.img, resolve, undefined, () => resolve(createFallbackTexture(character)));
                } else {
                    const paths = [character.img, `./${character.img}`, `/ED-DSP/${character.img}`];
                    let idx = 0;
                    function tryLoad() {
                        if (idx >= paths.length) { resolve(createFallbackTexture(character)); return; }
                        const loader = new THREE.TextureLoader();
                        loader.load(paths[idx], resolve, undefined, () => { idx++; tryLoad(); });
                    }
                    tryLoad();
                }
            });
        }

        async function createCharacterModel(char, x, y, z, idx) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            group.userData = { character: char, index: idx, originalY: y, hovered: false };
            
            const pedestalHeight = char.gender === 'F' ? 1.5 : 1.2;
            const pedestalGeometry = new THREE.CylinderGeometry(1.2, 1.4, pedestalHeight);
            const pedestalMaterial = new THREE.MeshLambertMaterial({ 
                color: char.cat === 'Ingénieur' ? 0xff6b35 : char.gender === 'F' ? 0x9333ea : 0x3b82f6,
                emissive: char.cat === 'Ingénieur' ? 0x331a0a : char.gender === 'F' ? 0x220a2a : 0x0a1433
            });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.y = pedestalHeight / 2;
            pedestal.castShadow = true;
            group.add(pedestal);
            
            const texture = await loadCharacterImage(char);
            const portraitFace = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3.5),
                new THREE.MeshLambertMaterial({ map: texture })
            );
            portraitFace.position.y = pedestalHeight + 2.8;
            portraitFace.position.z = 0.01;
            group.add(portraitFace);
            
            const portraitBack = new THREE.Mesh(
                new THREE.PlaneGeometry(2.5, 3.5),
                new THREE.MeshLambertMaterial({ map: texture })
            );
            portraitBack.position.y = pedestalHeight + 2.8;
            portraitBack.rotation.y = Math.PI;
            portraitBack.position.z = -0.01;
            group.add(portraitBack);
            
            if (char.gender === 'F') {
                const venusCanvas = document.createElement('canvas');
                venusCanvas.width = 256;
                venusCanvas.height = 256;
                const ctx = venusCanvas.getContext('2d');
                ctx.fillStyle = '#ff1493';
                ctx.beginPath();
                ctx.arc(128, 128, 120, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 20;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = 'Bold 180px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('♀', 128, 128);
                
                const venusTexture = new THREE.CanvasTexture(venusCanvas);
                const venusPedestalMesh = new THREE.Mesh(
                    new THREE.CircleGeometry(0.8, 32),
                    new THREE.MeshBasicMaterial({ map: venusTexture, transparent: true, side: THREE.DoubleSide })
                );
                venusPedestalMesh.position.y = pedestalHeight - 0.1;
                venusPedestalMesh.rotation.x = -Math.PI / 2;
                group.add(venusPedestalMesh);
            }
            
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 160;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(0, 0, 512, 160);
            ctx.strokeStyle = char.cat === 'Ingénieur' ? '#ff6b35' : '#3b82f6';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, 508, 156);
            ctx.fillStyle = '#fff';
            ctx.font = 'Bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(char.name, 256, 45);
            ctx.font = '18px Arial';
            ctx.fillStyle = '#ccc';
            ctx.fillText(char.years, 256, 75);
            ctx.fillStyle = char.cat === 'Ingénieur' ? '#ff6b35' : '#3b82f6';
            ctx.font = 'Bold 24px Arial';
            ctx.fillText(char.cat, 256, 115);
            
            const labelTexture = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(4.5, 1.4),
                new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true })
            );
            label.position.y = -0.5;
            group.add(label);
            
            const glowGeometry = new THREE.RingGeometry(1.8, 2.2, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: char.cat === 'Ingénieur' ? 0xff6b35 : char.gender === 'F' ? 0x9333ea : 0x3b82f6,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 0.1;
            glow.rotation.x = -Math.PI / 2;
            group.add(glow);
            
            const haloGeometry = new THREE.CylinderGeometry(2, 2, 0.1);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: char.cat === 'Ingénieur' ? 0xff6b35 : char.gender === 'F' ? 0x9333ea : 0x3b82f6,
                transparent: true,
                opacity: 0.2
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.y = 5;
            group.add(halo);
            
            group.rotation.y = angle;
            group.userData.hovered = false;
            scene.add(group);
            characters.push(group);
        }

        function createFallbackTexture(character) {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 560;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 0, 0, 560);
            if (character.cat === 'Ingénieur') {
                grad.addColorStop(0, '#ff8c42');
                grad.addColorStop(1, '#f7931e');
            } else if (character.gender === 'F') {
                grad.addColorStop(0, '#a855f7');
                grad.addColorStop(1, '#7c3aed');
            } else {
                grad.addColorStop(0, '#4a90e2');
                grad.addColorStop(1, '#1e40af');
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 400, 560);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 12;
            ctx.strokeRect(6, 6, 388, 548);
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.beginPath();
            ctx.arc(200, 150, 50, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(160, 200, 80, 120);
            if (character.gender === 'F') {
                ctx.fillStyle = '#ff69b4';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('♀', 200, 380);
            }
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(character.name, 200, 500);
            return new THREE.CanvasTexture(canvas);
        }

        function createTeleportMarker() {
            const markerGeometry = new THREE.RingGeometry(0.3, 0.5, 32);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            teleportMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            teleportMarker.rotation.x = -Math.PI / 2;
            teleportMarker.position.y = 0.05;
            teleportMarker.visible = false;
            scene.add(teleportMarker);
            
            const beamGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 16);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.6
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.y = 1;
            teleportMarker.add(beam);
        }

        function createInfoPanel() {
            const canvas = document.createElement('canvas');
            canvas.width = 500;
            canvas.height = 600;
            infoPanel = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 6),
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 0.95 })
            );
            infoPanel.position.set(-10, 5, 0);
            infoPanel.visible = false;
            scene.add(infoPanel);
        }

        function updateInfoPanel(char) {
            if (!infoPanel) return;
            const canvas = infoPanel.material.map.image;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 500, 600);
            ctx.fillStyle = 'rgba(15,25,45,0.98)';
            ctx.fillRect(0, 0, 500, 600);
            ctx.strokeStyle = char.cat === 'Ingénieur' ? '#ff6b35' : char.gender === 'F' ? '#9333ea' : '#3b82f6';
            ctx.lineWidth = 8;
            ctx.strokeRect(10, 10, 480, 580);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(char.name, 250, 60);
            if (char.gender === 'F') {
                ctx.fillStyle = '#ff69b4';
                ctx.font = 'bold 36px Arial';
                ctx.fillText('♀', 60, 60);
            }
            ctx.font = '20px Arial';
            ctx.fillStyle = '#ddd';
            ctx.fillText(char.years, 250, 90);
            ctx.fillStyle = char.cat === 'Ingénieur' ? '#ff6b35' : '#9333ea';
            ctx.fillText(char.cat, 250, 120);
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            wrapText(ctx, char.short || '', 30, 160, 440, 22);
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ccc';
            wrapText(ctx, char.bio || '', 30, 250, 440, 20);
            infoPanel.material.map.needsUpdate = true;
            infoPanel.visible = true;
            positionInfoPanelNearCharacter();
        }

        function positionInfoPanelNearCharacter() {
            if (!infoPanel || !selectedCharacter || !infoPanel.visible) return;
            const charGroup = characters.find(c => c.userData.character === selectedCharacter);
            if (!charGroup) return;
            const charPos = charGroup.position.clone();
            const camPos = isVRActive && renderer.xr.isPresenting ? renderer.xr.getCamera(camera).position : camera.position;
            const dirToCamera = new THREE.Vector3().subVectors(camPos, charPos).normalize();
            const rightVector = new THREE.Vector3(-dirToCamera.z, 0, dirToCamera.x);
            infoPanel.position.copy(charPos);
            infoPanel.position.y = 3;
            infoPanel.position.add(rightVector.multiplyScalar(5));
            infoPanel.lookAt(camPos);
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            if (!text || typeof text !== 'string') return;
            const words = text.split(' ');
            let line = '';
            let currentY = y;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    ctx.fillText(line, x, currentY);
                    line = words[n] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, currentY);
        }

        function onSelectStart(event) {
            const controller = event.target;
            controller.userData.isSelecting = true;
            checkIntersections(controller, true);
        }

        function onSelectEnd(event) {
            const controller = event.target;
            controller.userData.isSelecting = false;
            if (currentTeleportPosition && teleportMarker.visible && dolly) {
                dolly.position.set(currentTeleportPosition.x, 0, currentTeleportPosition.z);
                showVRStatus('Téléporté!', 'success');
            }
            if (teleportMarker) teleportMarker.visible = false;
            currentTeleportPosition = null;
        }

        function onSqueezeStart(event) {
            if (infoPanel && infoPanel.visible) {
                infoPanel.visible = false;
                selectedCharacter = null;
                showVRStatus('Panneau fermé', 'info');
            }
        }

        function checkIntersections(controller, isSelecting = false) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            const intersects = raycaster.intersectObjects(characters, true);
            if (intersects.length > 0 && isSelecting) {
                let group = intersects[0].object.parent;
                while (group && !group.userData.character) group = group.parent;
                if (group && group.userData.character) {
                    selectedCharacter = group.userData.character;
                    updateInfoPanel(selectedCharacter);
                    showVRStatus('Personnage: ' + selectedCharacter.name, 'success');
                    return;
                }
            }
            const floorIntersects = raycaster.intersectObjects(scene.children.filter(obj => obj.userData.isFloor));
            if (floorIntersects.length > 0 && isSelecting) {
                currentTeleportPosition = floorIntersects[0].point.clone();
                teleportMarker.position.copy(currentTeleportPosition);
                teleportMarker.position.y = 0.05;
                teleportMarker.visible = true;
            }
        }

        function onMouseClick(event) {
            if (isVRActive) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(characters, true);
            if (intersects.length > 0) {
                let group = intersects[0].object.parent;
                while (group && !group.userData.character) group = group.parent;
                if (group && group.userData.character) {
                    selectedCharacter = group.userData.character;
                    updateInfoPanel(selectedCharacter);
                }
            }
        }

        function onMouseMove(event) {
            if (isVRActive) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(characters, true);
            characters.forEach(c => c.userData.hovered = false);
            if (intersects.length > 0) {
                let group = intersects[0].object.parent;
                while (group && !group.userData.character) group = group.parent;
                if (group) group.userData.hovered = true;
            }
        }

        function resetView() {
            if (dolly) dolly.position.set(0, 0, 0);
            camera.position.set(0, 1.6, 5);
            camera.lookAt(0, 2, 0);
            if (infoPanel) infoPanel.visible = false;
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
        }

        function randomSelection() {
            if (characters.length > 0) {
                const char = characters[Math.floor(Math.random() * characters.length)];
                selectedCharacter = char.userData.character;
                updateInfoPanel(selectedCharacter);
            }
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const time = Date.now() * 0.001;
            if (autoRotate && !isVRActive) {
                camera.position.x = Math.cos(time * 0.1) * 12;
                camera.position.z = Math.sin(time * 0.1) * 12;
                camera.lookAt(0, 2, 0);
            }
            if (frame && xrSession && xrReferenceSpace) {
                try {
                    const pose = frame.getViewerPose(xrReferenceSpace);
                    if (pose) {
                        controllers.forEach(controller => {
                            if (controller.userData.isSelecting) {
                                checkIntersections(controller, false);
                            }
                        });
                    }
                } catch (e) {}
            }
            characters.forEach((char, i) => {
                char.rotation.y += 0.003;
                if (char.userData.hovered) {
                    char.position.y = char.userData.originalY + 0.5;
                    char.scale.setScalar(1.1);
                } else {
                    char.position.y = char.userData.originalY + Math.sin(time + i) * 0.1;
                    char.scale.setScalar(1);
                }
            });
            if (infoPanel && infoPanel.visible) {
                positionInfoPanelNearCharacter();
            }
            if (teleportMarker && teleportMarker.visible) {
                teleportMarker.rotation.z = time * 2;
                teleportMarker.material.opacity = 0.5 + Math.sin(time * 5) * 0.3;
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.resetView = resetView;
        window.toggleAutoRotate = toggleAutoRotate;
        window.randomSelection = randomSelection;

        document.addEventListener('DOMContentLoaded', init);
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && infoPanel && infoPanel.visible) {
                infoPanel.visible = false;
                selectedCharacter = null;
            }
        });
    </script>
</body>
</html>